**Также известен как:** Extract Class

### Проблема
Один класс работает за двоих.
```
class Person {
private:
	std::string name;
	int officeNumberCode;
	int officeNumber;

public:
	getTelephoneNumber();
};
```

### Решение
Создайте новый класс, переместите в него поля и методы, отвечающие за определённую функциональность.
```
class TelephoneNumber {
private:
	int officeNumberCode;
	int officeNumber;

public:
	getTelephoneNumber();
};

class Person {
private:
	std::string name;
	TelephoneNumber num;

public:
	getTelephoneNumber();
};
```

### Причины рефакторинга
Классы всегда изначально выглядят чёткими и понятными. Они выполняют свою работу и не лезут в обязанности других классов. Однако, с течением жизни программы добавляется один метод  — тут, одно поле  — там. В результате некоторые классы получают массу дополнительных обязанностей.

### Достоинства
- Этот рефакторинг призван помочь в соблюдении принципа _единственной обязанности класса_. Это делает код ваших классов очевиднее и понятнее.
    
- Классы с единственной обязанностью более надёжны и устойчивы к изменениям. Например, у вас есть класс, отвечающий за десять разных вещей. И когда вам придётся вносить в него изменения, вы рискуете при корректировках одной вещи сломать другие.

### Недостатки
Если при проведении этого рефакторинга вы перестараетесь, придётся прибегнуть к [встраиванию класса](https://refactoring.guru/ru/inline-class).

### Порядок рефакторинга
Перед началом рефакторинга обязательно определите, как именно следует разделить обязанности класса.

1. Создайте новый класс, который будет содержать выделенную функциональность.
    
2. Создайте связь между старым и новым классом. Лучше всего, если эта связь будет односторонней; при этом второй класс можно будет без проблем использовать повторно. С другой стороны, если вы считаете, что это необходимо, всегда можно создать двустороннюю связь.
    
3. Используйте [перемещение поля](Перемещение%20поля.md) и [перемещение метода](Перемещение%20метода.md) для каждого поля и метода, которые вы решили переместить в новый класс. Для методов имеет смысл начинать с приватных, таким образом вы снижаете вероятность допустить массу ошибок. Старайтесь двигаться понемногу и тестировать результат после каждого перемещения, это избавит вас от необходимости исправлять большое число ошибок в самом конце.
    
    После того как с перемещением покончено, пересмотрите ещё раз на получившиеся классы. Возможно, старый класс теперь имеет смысл назвать по-другому ввиду его изменившихся обязанностей. Проверьте ещё раз, можно ли избавиться от двусторонней связи между классами, если она возникла.
    
4. Ещё одним нюансом является доступность нового класса извне. Вы можете полностью спрятать его от клиента, сделав приватным, управляя при этом его полями из старого класса. Либо сделать его публичным, предоставив клиенту возможность напрямую менять значения. Решение зависит от того, насколько безопасны для поведения старого класса будут неожиданные прямые изменения значений в новом классе.
### Анти-рефакторинг
[Встраивание класса](Встраивание%20класса.md)

### Родственные рефакторинги
[Извлечение подкласса](https://refactoring.guru/ru/extract-subclass)
[Замена простого поля объектом](https://refactoring.guru/ru/replace-data-value-with-object)

### Борется с запахом
[Дублирование кода](Дублирование%20кода.md)
[Большой класс](Большой%20класс.md)
[Расходящиеся модификации](Расходящиеся%20модификации.md)
[Группы данных](Группы%20данных.md)
[Одержимость элементарными типами](Одержимость%20элементарными%20типами.md)
[Временное поле](Временное%20поле.md)
[Неуместная близость](Неуместная%20близость.md)