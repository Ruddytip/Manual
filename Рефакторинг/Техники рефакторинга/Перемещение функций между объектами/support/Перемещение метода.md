**Также известен как:** Move Method

### Проблема
Метод используется в другом классе больше, чем в собственном.
```
class class1 {
	void aMethod();
};

class class2 {
	
};
```

### Решение
Создайте новый метод в классе, который использует его больше других, и перенесите туда код из старого метода. Код оригинального метода превратите в обращение к новому методу в другом классе либо уберите его вообще.
```
class class1 {
	
};

class class2 {
	void aMethod();
};
```

### Причины рефакторинга
1. Вы хотите переместить метод в класс, который содержит данные, с которыми, в основном, работает этот метод. Этим вы **увеличиваете связность внутри классов**.
    
2. Вы хотите переместить метод, чтобы убрать или уменьшить зависимость класса, вызывающего этот метод, от класса, в котором он находился. Это может быть полезно, если вызывающий класс уже имеет зависимость от класса, куда вы планируете перенести метод. Таким образом, вы **уменьшаете связанность между классами**.

### Порядок рефакторинга
1. Проверьте все фичи, используемые старым методом в его же классе. Возможно, их тоже следует переместить. Руководствуйтесь таким правилом — если фича используется только интересующим вас методом, её точно следует переносить. Если фича используется и другими методами, возможно, следует перенести и эти методы. Иногда гораздо проще перенести пачку методов, чем настраивать взаимодействие между ними в разных классах.
    
    Проверьте, не определён ли метод в суперклассах и подклассах приемника. Если это так, вам придётся либо отказаться от идеи переноса, либо реализовать в классе-получателе подобие полиморфизма, чтобы обеспечить различную функциональность метода, которая была разнесена по классам-донорам.
    
2. Объявите новый метод в классе-приёмнике. Возможно, следует придумать для метода новое имя, которое в новом классе будет подходить ему больше.
    
3. Определите, как вы будете обращаться к классу-получателю. Вполне возможно, у вас уже есть поле или метод, которые возвращают подходящий объект, но если нет, нужно будет написать новый метод или поле, в котором бы хранился объект класса-получателя.
    
    Теперь у вас есть способ обратиться к объекту-получателю и новый метод в его классе. С этим всем вы уже можете превратить старый метод в обращение к новому методу.
    
4. Оцените, есть ли возможность удалить старый метод вообще? При этом нужно будет во всех местах, где используется этот метод, поставить обращение к новому.

### Родственные рефакторинги
[Извлечение метода](Извлечение%20метода.md)
[Перемещение поля](Перемещение%20поля.md)

### Помогает рефакторингу
[Извлечение класса](https://refactoring.guru/ru/extract-class)
[Встраивание класса](https://refactoring.guru/ru/inline-class)
[Замена параметров объектом](https://refactoring.guru/ru/introduce-parameter-object)

### Борется с запахом
[Стрельба дробью](Стрельба%20дробью.md)
[Завистливые функции](Завистливые%20функции.md)
[Операторы switch](Операторы%20switch.md)
[Параллельные иерархии наследования](Параллельные%20иерархии%20наследования.md)
[Цепочка вызовов](Цепочка%20вызовов.md)
[Неуместная близость](Неуместная%20близость.md)
[Класс данных](Класс%20данных.md)