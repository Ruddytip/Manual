**Также известен как:** Hide Delegate

### Проблема
Клиент получает объект B из поля или метода объекта А. Затем клиент вызывает какой-то метод объекта B.
![[HIDE_DELEGATE_TRUBLE.png]]

### Решение
Создайте новый метод в классе А, который бы делегировал вызов объекту B. Таким образом, клиент перестанет знать о классе В и зависеть от него.

![[HIDE_DELEGATE_.png]]

### Причины рефакторинга
Для начала следует определиться с названиями:

- _Сервер_ — это объект, к которому клиент имеет непосредственный доступ.
    
- _Делегат_ — это конечный объект, который содержит функциональность, нужную клиенту.
    

Цепочка вызовов появляется тогда, когда клиент запрашивает у одного объекта другой, потом второй объект запрашивает еще один и т. д. Такие последовательности вызовов означают, что клиент связан с навигацией по структуре классов. Любые изменения промежуточных связей означают необходимость модификации клиента.

### Достоинства

Скрывает делегирование от клиента. Чем меньше клиентский код знает подробностей о связях между объектами, тем проще будет впоследствии вносить изменения в программу.

### Недостатки

Если требуется создать слишком много делегирующих методов, _класс-сервер_ рискует превратиться в лишнее промежуточное звено и привести к запашку [посредник](Посредник.md).

### Порядок рефакторинга

1. Для каждого метода _класса-делегата_, вызываемого клиентом, нужно создать метод в _классе-сервере_, который бы делегировал вызов _классу-делегату_.
    
2. Измените код клиента так, чтобы он вызывал методы _класса-сервера_.
    
3. Если после всех изменений клиент больше не нуждается в _классе-делегате_, можно убрать метод доступа к _классу-делегату_ из _класса-сервера_ (тот метод, который использовался изначально для получения _класса-делегата_).

### Анти-рефакторинг
[Удаление посредника](Удаление%20посредника.md)

### Борется с запахом
[Цепочка вызовов](Цепочка%20вызовов.md)
[Неуместная близость](Неуместная%20близость.md)