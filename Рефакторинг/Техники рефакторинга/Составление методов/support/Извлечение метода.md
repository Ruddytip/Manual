**Также известен как:** Extract Method

### Проблема
У вас есть фрагмент кода, который можно сгруппировать.
```
void printOwing()
{
  printBanner();

  // Print details.
  std::cout << "name: " << name << std::endl;
  std::cout << "amount: " << getOutstanding() << std::endl;
}
```

### Решение
Выделите участок кода в новый метод (или функцию) и вызовите этот метод вместо старого кода.
```
void printOwing()
{
  printBanner();
  printDetails(getOutstanding());
}

void printDetails(double outstanding)
{
  std::cout << "name: " << name << std::endl;
  std::cout << "amount: " << outstanding << std::endl;
}
```

### Причины рефакторинга
Чем больше строк кода в методе, тем сложнее разобраться в том, что он делает. Это основная проблема, которую решает этот рефакторинг.

Извлечение метода не только убивает множество запашков в коде, но и является одним из этапов множества других рефакторингов.

### Достоинства
- Улучшает читабельность кода. Постарайтесь дать новому методу название, которое бы отражало суть того, что он делает. Например, `createOrder()`, `renderCustomerInfo()` и т. д.
    
- Убирает дублирование кода. Иногда код, вынесенный в метод, можно найти и в других местах программы. В таком случае, имеет смысл заменить найденные участки кода вызовом вашего нового метода.
    
- Изолирует независимые части кода, уменьшая вероятность ошибок (например, по вине переопределения не той переменной).

### Порядок рефакторинга
1. Создайте новый метод и назовите его так, чтобы название отражало суть того, что будет делать этот метод.
    
2. Скопируйте беспокоящий вас фрагмент кода в новый метод. Удалите этот фрагмент из старого места и замените вызовом вашего нового метода.
    
    Найдите все переменные, которые использовались в этом фрагменте кода. Если они были объявлены внутри этого фрагмента и не используются вне его, просто оставьте их без изменений — они станут локальными переменными нового метода.
    
3. Если переменные объявлены перед интересующим вас участком кода, значит, их следует передать в параметры вашего нового метода, чтобы использовать значения, которые в них находились ранее. Иногда от таких переменных проще избавиться с помощью [замены переменных вызовом метода](https://refactoring.guru/ru/replace-temp-with-query).
    
4. Если вы видите, что локальная переменная как-то изменяется в вашем участке кода, это может означать, что её изменённое значение понадобится дальше в основном методе. Проверьте это. Если подозрение подтвердилось, значение этой переменной следует возвратить в основной метод, чтобы ничего не сломать.

### Анти-рефакторинг
[Встраивание метода](Встраивание%20метода.md)

### Родственные рефакторинги
[Перемещение метода](https://refactoring.guru/ru/move-method)

### Помогает рефакторингу
[Замена параметров объектом](https://refactoring.guru/ru/introduce-parameter-object)
[Создание шаблонного метода](https://refactoring.guru/ru/form-template-method)
[Параметризация метода](https://refactoring.guru/ru/parameterize-method)

### Борется с запахом
[Дублирование кода](Дублирование%20кода.md)
[Длинный метод](Длинный%20метод.md)
[Завистливые функции](Завистливые%20функции.md)
[Операторы switch](Операторы%20switch.md)
[Цепочка вызовов](Цепочка%20вызовов.md)
[Комментарии](Комментарии.md)
[Класс данных](Класс%20данных.md)